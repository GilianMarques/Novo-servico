// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using conta.azul;
//
//    var ordemDeVenda = OrdemDeVenda.FromJson(jsonString);

namespace conta.azul.modelos
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using System.Linq;
    using System.Text.RegularExpressions;
    using file.io;
    using FileIO;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;
    using NovoServico.outros;

    public partial class OrdemDeVenda
    {
        //--------------------------------------------------------------------------------  JSON
        [JsonProperty("id")]
        public String Id { get; set; }

        [JsonProperty("ca_id")]
        public long CaId { get; set; }

        [JsonProperty("number")]
        public long Number { get; set; }

        [JsonProperty("emission")]
        public DateTimeOffset Emission { get; set; }

        [JsonProperty("status")]
        public String Status { get; set; }

        [JsonProperty("scheduled")]
        public bool Scheduled { get; set; }

        [JsonProperty("customer_id")]
        public String CustomerId { get; set; }

        [JsonProperty("customer")]
        public Customer Customer { get; set; }

        [JsonProperty("discount")]
        public Discount Discount { get; set; }

        [JsonProperty("product_discount")]
        public Discount ProductDiscount { get; set; }

        [JsonProperty("service_discount")]
        public Discount ServiceDiscount { get; set; }

        [JsonProperty("payment")]
        public Payment Payment { get; set; }

        [JsonProperty("payment_terms")]
        public string PaymentTerms { get; set; }

        [JsonProperty("notes")]
        public string Notes { get; set; }

        [JsonProperty("shipping_cost")]
        public double? ShippingCost { get; set; }

        [JsonProperty("total")]
        public double Total { get; set; }

        [JsonProperty("seller")]
        public Seller Seller { get; set; }

        [JsonProperty("proposal_date")]
        public DateTimeOffset? ProposalDate { get; set; }

        [JsonProperty("expiration")]
        public DateTimeOffset? Expiration { get; set; }

        [JsonProperty("introduction")]
        public string Introduction { get; set; }

        [JsonProperty("shipping_forecast")]
        public string ShippingForecast { get; set; }

        [JsonProperty("category_id")]
        public object CategoryId { get; set; }

        //--------------------------------------------------------------------------------  JSON

        //--------------------------------------------------------------------------------  PROJETO

        public DateTime dataDeEntrega;
        public ListaDeItens[] ListaDeItens { get; internal set; }

        /// <summary>
        /// cria a descriçao com base na ordem de venda e no template definido pelo usuario no arquivo de texto
        /// </summary>
        /// <returns></returns>
        public string carregarDescricao()
        {


            String? templateDeItem = Preferencias.inst().getString(Preferencias.trelloDescTemplate);
            String? identificacaoNoContaAzul = Preferencias.inst().getString(Preferencias.trelloTemplateIdContaAzul);
            String descricaoTrello = "";

            // lista com lista com array

            for (int i = 0; i < ListaDeItens.Length; i++)
            {
                var item = ListaDeItens[i];

                String tempItem = templateDeItem
                        .Replace("{@itemNumber}", (i + 1 + ""))
                        .Replace("{@itemName}", item.Item.Name.ToUpper())
                        .Replace("{@itemDesc}", char.ToUpper(item.Description[0]) + item.Description.Substring(1).ToLower())
                        .Replace("{@ItemAmount}", item.Quantity + (item.Quantity > 1 ? " UNIDADES" : " UNIDADE"));

                descricaoTrello += tempItem;

            }

            String linkNumOS = "[" + Number.ToString() + "](https://app.contaazul.com/#/vendas-e-orcamentos/visualizar-orcamento/" + CaId + ")";
            descricaoTrello += "\n\n" + identificacaoNoContaAzul.Replace("{@idNumber}", linkNumOS);

            return descricaoTrello;

        }

        public string? carregarDataDeEntregaPrevista()
        {
            // 12 dias uteis ou 12 dias. (sao sempre dias uteis independente de estar escrito ou nao) 
            String? previsao = ShippingForecast;


            if (previsao != null)
            {
                if (new Regex("[0-9]+[\\/][0-9]+[\\/][0-9]{4}").IsMatch(previsao))
                    return previsao; 
                else if(!previsao.Any(char.IsDigit)) return null; // nao tem nenhum numero da previsao de entrega, logo nao sera possivel determinar a data correta

                Regex regexObj = new Regex(@"[^\d]");
                int diasUteisPrevistos = int.Parse(regexObj.Replace(previsao, ""));

                /* se a previsao for 7 dias uteis, começo a buscar a qtd de dias uteis no intervalo passando a data de hj +7 */
                int diasAmais = diasUteisPrevistos;
                int diasUteisNoPeriodo = 0;

                var hoje = DateTime.Now;
                DateTime dataDeEntrega;


                do
                {
                    dataDeEntrega = DateTime.Now.AddDays(diasAmais);
                    diasUteisNoPeriodo = obterDiasUteis(hoje, dataDeEntrega);
                    diasAmais++;
                    // diasUteisNoPeriodo tem q ser = diasUteisPrevistos+1 pq o dia em q o serviço é criado nao conta mesmo sendo dia util
                } while (diasUteisNoPeriodo <= diasUteisPrevistos);

                return dataDeEntrega.ToString("dd/MM/yyyy");

            }

            else return null;
        }

        /// <summary>
        /// Calcula os dias uteis no periodo recebido considerando sabados e domingos incluindo o 1° e ultimo dia do periodo recebido no calculo.
        /// Exemplo: entre 19/08/2022 (sexta-feira) e  25/08/2022 (quinta-feira)  terao 5 dias uteis 
        /// Ajuda: para calcular a data de entrega do serviço use o valor retornado dessa função +1 dia pq o dia em que o serviço e criado nao conta mesmo sendo um dia util
        /// </summary>
        /// <param name="startD"></param>
        /// <param name="endD"></param>
        /// <returns></returns>
        private int obterDiasUteis(DateTime startD, DateTime endD)
        {
            double calcBusinessDays =
                1 + ((endD - startD).TotalDays * 5 -
                (startD.DayOfWeek - endD.DayOfWeek) * 2) / 7;

            if (endD.DayOfWeek == DayOfWeek.Saturday) calcBusinessDays--;
            if (startD.DayOfWeek == DayOfWeek.Sunday) calcBusinessDays--;

            return (int)calcBusinessDays;
        }

        //--------------------------------------------------------------------------------  PROJETO
    }

    public partial class Customer
    {
        [JsonProperty("id")]
        public Guid Id { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("company_name")]
        public string CompanyName { get; set; }

        [JsonProperty("email")]
        public string Email { get; set; }

        [JsonProperty("person_type")]
        public String PersonType { get; set; }
    }

    public partial class Discount
    {
        [JsonProperty("measure_unit")]
        public MeasureUnit MeasureUnit { get; set; }

        [JsonProperty("rate")]
        public double Rate { get; set; }
    }

    public partial class Payment
    {
        [JsonProperty("type")]
        public String Type { get; set; }

        [JsonProperty("method")]
        public String Method { get; set; }

        [JsonProperty("installments")]
        public Installment[] Installments { get; set; }

        [JsonProperty("financial_account_id")]
        public String? FinancialAccountId { get; set; }

        [JsonProperty("financial_account")]
        public FinancialAccount FinancialAccount { get; set; }
    }

    public partial class FinancialAccount
    {
        [JsonProperty("uuid")]
        public String Uuid { get; set; }

        [JsonProperty("name")]
        public String Name { get; set; }

        [JsonProperty("bank_account_type")]
        public String BankAccountType { get; set; }

        [JsonProperty("billet_configured")]
        public bool BilletConfigured { get; set; }
    }

    public partial class Installment
    {
        [JsonProperty("number")]
        public long? Number { get; set; }

        [JsonProperty("value")]
        public double Value { get; set; }

        [JsonProperty("due_date")]
        public DateTimeOffset? DueDate { get; set; }

        [JsonProperty("status")]
        public InstallmentStatus Status { get; set; }

        [JsonProperty("note")]
        public string Note { get; set; }

        [JsonProperty("hasBillet")]
        public bool HasBillet { get; set; }
    }

    public partial class Seller
    {
        [JsonProperty("id")]
        public String Id { get; set; }

        [JsonProperty("name")]
        public String Name { get; set; }
    }

    public enum PersonType { Legal, Natural };

    public enum MeasureUnit { Percent, Value };

    public enum BankAccountType { Capaymentsaccount, Cashaccount, Checkingaccount, Otheraccount, Paymentssystem };

    public enum FinancialAccountName { BbContaCorrente, CaixaComposição, LinkMaquininha, PgtoPeloClienteBonificação, Picpay, RecebaFácil };

    public enum InstallmentStatus { Acquitted, Overdue, Pending };

    public enum Method { BankingBillet, BankingDeposit, Cash, Check, CreditCard, DebitCard, DigitalWallet, InstantPayment, PaymentLink, StoreCredit };

    public enum TypeEnum { Cash, Times };

    public enum SellerName { PatriciaLeonel, VanessaZavarize };

    public enum OrdemDeVendaStatus { Committed, Proposal };

    public partial class OrdemDeVenda
    {
        public static OrdemDeVenda[] FromJson(string json) => JsonConvert.DeserializeObject<OrdemDeVenda[]>(json);
    }

    public static class Serialize2
    {
        public static string ToJson(this OrdemDeVenda[] self) => JsonConvert.SerializeObject(self, conta.azul.modelos.Converter2.Settings);
    }

    internal static class Converter2
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                PersonTypeConverter.Singleton,
                MeasureUnitConverter.Singleton,
                BankAccountTypeConverter.Singleton,
                FinancialAccountNameConverter.Singleton,
                InstallmentStatusConverter.Singleton,
                MethodConverter.Singleton,
                TypeEnumConverter.Singleton,
                SellerNameConverter.Singleton,
                OrdemDeVendaStatusConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class PersonTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PersonType) || t == typeof(PersonType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "LEGAL":
                    return PersonType.Legal;
                case "NATURAL":
                    return PersonType.Natural;
            }
            throw new Exception("Cannot unmarshal type PersonType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PersonType)untypedValue;
            switch (value)
            {
                case PersonType.Legal:
                    serializer.Serialize(writer, "LEGAL");
                    return;
                case PersonType.Natural:
                    serializer.Serialize(writer, "NATURAL");
                    return;
            }
            throw new Exception("Cannot marshal type PersonType");
        }

        public static readonly PersonTypeConverter Singleton = new PersonTypeConverter();
    }

    internal class MeasureUnitConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(MeasureUnit) || t == typeof(MeasureUnit?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "PERCENT":
                    return MeasureUnit.Percent;
                case "VALUE":
                    return MeasureUnit.Value;
            }
            throw new Exception("Cannot unmarshal type MeasureUnit");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (MeasureUnit)untypedValue;
            switch (value)
            {
                case MeasureUnit.Percent:
                    serializer.Serialize(writer, "PERCENT");
                    return;
                case MeasureUnit.Value:
                    serializer.Serialize(writer, "VALUE");
                    return;
            }
            throw new Exception("Cannot marshal type MeasureUnit");
        }

        public static readonly MeasureUnitConverter Singleton = new MeasureUnitConverter();
    }

    internal class BankAccountTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BankAccountType) || t == typeof(BankAccountType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CAPAYMENTSACCOUNT":
                    return BankAccountType.Capaymentsaccount;
                case "CASHACCOUNT":
                    return BankAccountType.Cashaccount;
                case "CHECKINGACCOUNT":
                    return BankAccountType.Checkingaccount;
                case "OTHERACCOUNT":
                    return BankAccountType.Otheraccount;
                case "PAYMENTSSYSTEM":
                    return BankAccountType.Paymentssystem;
            }
            throw new Exception("Cannot unmarshal type BankAccountType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (BankAccountType)untypedValue;
            switch (value)
            {
                case BankAccountType.Capaymentsaccount:
                    serializer.Serialize(writer, "CAPAYMENTSACCOUNT");
                    return;
                case BankAccountType.Cashaccount:
                    serializer.Serialize(writer, "CASHACCOUNT");
                    return;
                case BankAccountType.Checkingaccount:
                    serializer.Serialize(writer, "CHECKINGACCOUNT");
                    return;
                case BankAccountType.Otheraccount:
                    serializer.Serialize(writer, "OTHERACCOUNT");
                    return;
                case BankAccountType.Paymentssystem:
                    serializer.Serialize(writer, "PAYMENTSSYSTEM");
                    return;
            }
            throw new Exception("Cannot marshal type BankAccountType");
        }

        public static readonly BankAccountTypeConverter Singleton = new BankAccountTypeConverter();
    }

    internal class FinancialAccountNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FinancialAccountName) || t == typeof(FinancialAccountName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "BB - CONTA CORRENTE":
                    return FinancialAccountName.BbContaCorrente;
                case "CAIXA COMPOSIÇÃO":
                    return FinancialAccountName.CaixaComposição;
                case "LINK / MAQUININHA":
                    return FinancialAccountName.LinkMaquininha;
                case "PGTO PELO CLIENTE / BONIFICAÇÃO":
                    return FinancialAccountName.PgtoPeloClienteBonificação;
                case "PICPAY":
                    return FinancialAccountName.Picpay;
                case "Receba Fácil":
                    return FinancialAccountName.RecebaFácil;
            }
            throw new Exception("Cannot unmarshal type FinancialAccountName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FinancialAccountName)untypedValue;
            switch (value)
            {
                case FinancialAccountName.BbContaCorrente:
                    serializer.Serialize(writer, "BB - CONTA CORRENTE");
                    return;
                case FinancialAccountName.CaixaComposição:
                    serializer.Serialize(writer, "CAIXA COMPOSIÇÃO");
                    return;
                case FinancialAccountName.LinkMaquininha:
                    serializer.Serialize(writer, "LINK / MAQUININHA");
                    return;
                case FinancialAccountName.PgtoPeloClienteBonificação:
                    serializer.Serialize(writer, "PGTO PELO CLIENTE / BONIFICAÇÃO");
                    return;
                case FinancialAccountName.Picpay:
                    serializer.Serialize(writer, "PICPAY");
                    return;
                case FinancialAccountName.RecebaFácil:
                    serializer.Serialize(writer, "Receba Fácil");
                    return;
            }
            throw new Exception("Cannot marshal type FinancialAccountName");
        }

        public static readonly FinancialAccountNameConverter Singleton = new FinancialAccountNameConverter();
    }

    internal class InstallmentStatusConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(InstallmentStatus) || t == typeof(InstallmentStatus?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ACQUITTED":
                    return InstallmentStatus.Acquitted;
                case "OVERDUE":
                    return InstallmentStatus.Overdue;
                case "PENDING":
                    return InstallmentStatus.Pending;
            }
            throw new Exception("Cannot unmarshal type InstallmentStatus");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (InstallmentStatus)untypedValue;
            switch (value)
            {
                case InstallmentStatus.Acquitted:
                    serializer.Serialize(writer, "ACQUITTED");
                    return;
                case InstallmentStatus.Overdue:
                    serializer.Serialize(writer, "OVERDUE");
                    return;
                case InstallmentStatus.Pending:
                    serializer.Serialize(writer, "PENDING");
                    return;
            }
            throw new Exception("Cannot marshal type InstallmentStatus");
        }

        public static readonly InstallmentStatusConverter Singleton = new InstallmentStatusConverter();
    }

    internal class MethodConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Method) || t == typeof(Method?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "BANKING_BILLET":
                    return Method.BankingBillet;
                case "BANKING_DEPOSIT":
                    return Method.BankingDeposit;
                case "CASH":
                    return Method.Cash;
                case "CHECK":
                    return Method.Check;
                case "CREDIT_CARD":
                    return Method.CreditCard;
                case "DEBIT_CARD":
                    return Method.DebitCard;
                case "DIGITAL_WALLET":
                    return Method.DigitalWallet;
                case "INSTANT_PAYMENT":
                    return Method.InstantPayment;
                case "PAYMENT_LINK":
                    return Method.PaymentLink;
                case "STORE_CREDIT":
                    return Method.StoreCredit;
            }
            throw new Exception("Cannot unmarshal type Method");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Method)untypedValue;
            switch (value)
            {
                case Method.BankingBillet:
                    serializer.Serialize(writer, "BANKING_BILLET");
                    return;
                case Method.BankingDeposit:
                    serializer.Serialize(writer, "BANKING_DEPOSIT");
                    return;
                case Method.Cash:
                    serializer.Serialize(writer, "CASH");
                    return;
                case Method.Check:
                    serializer.Serialize(writer, "CHECK");
                    return;
                case Method.CreditCard:
                    serializer.Serialize(writer, "CREDIT_CARD");
                    return;
                case Method.DebitCard:
                    serializer.Serialize(writer, "DEBIT_CARD");
                    return;
                case Method.DigitalWallet:
                    serializer.Serialize(writer, "DIGITAL_WALLET");
                    return;
                case Method.InstantPayment:
                    serializer.Serialize(writer, "INSTANT_PAYMENT");
                    return;
                case Method.PaymentLink:
                    serializer.Serialize(writer, "PAYMENT_LINK");
                    return;
                case Method.StoreCredit:
                    serializer.Serialize(writer, "STORE_CREDIT");
                    return;
            }
            throw new Exception("Cannot marshal type Method");
        }

        public static readonly MethodConverter Singleton = new MethodConverter();
    }

    internal class TypeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TypeEnum) || t == typeof(TypeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CASH":
                    return TypeEnum.Cash;
                case "TIMES":
                    return TypeEnum.Times;
            }
            throw new Exception("Cannot unmarshal type TypeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TypeEnum)untypedValue;
            switch (value)
            {
                case TypeEnum.Cash:
                    serializer.Serialize(writer, "CASH");
                    return;
                case TypeEnum.Times:
                    serializer.Serialize(writer, "TIMES");
                    return;
            }
            throw new Exception("Cannot marshal type TypeEnum");
        }

        public static readonly TypeEnumConverter Singleton = new TypeEnumConverter();
    }

    internal class SellerNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SellerName) || t == typeof(SellerName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Patricia Leonel":
                    return SellerName.PatriciaLeonel;
                case "Vanessa Zavarize":
                    return SellerName.VanessaZavarize;
            }
            throw new Exception("Cannot unmarshal type SellerName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SellerName)untypedValue;
            switch (value)
            {
                case SellerName.PatriciaLeonel:
                    serializer.Serialize(writer, "Patricia Leonel");
                    return;
                case SellerName.VanessaZavarize:
                    serializer.Serialize(writer, "Vanessa Zavarize");
                    return;
            }
            throw new Exception("Cannot marshal type SellerName");
        }

        public static readonly SellerNameConverter Singleton = new SellerNameConverter();
    }

    internal class OrdemDeVendaStatusConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OrdemDeVendaStatus) || t == typeof(OrdemDeVendaStatus?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "COMMITTED":
                    return OrdemDeVendaStatus.Committed;
                case "PROPOSAL":
                    return OrdemDeVendaStatus.Proposal;
            }
            throw new Exception("Cannot unmarshal type OrdemDeVendaStatus");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (OrdemDeVendaStatus)untypedValue;
            switch (value)
            {
                case OrdemDeVendaStatus.Committed:
                    serializer.Serialize(writer, "COMMITTED");
                    return;
                case OrdemDeVendaStatus.Proposal:
                    serializer.Serialize(writer, "PROPOSAL");
                    return;
            }
            throw new Exception("Cannot marshal type OrdemDeVendaStatus");
        }

        public static readonly OrdemDeVendaStatusConverter Singleton = new OrdemDeVendaStatusConverter();
    }
}
